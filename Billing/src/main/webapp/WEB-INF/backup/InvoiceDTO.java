/*
 * Generated by XDoclet - Do not edit!
 */
package com.csr.billing.dto;

/**
 * Value object for InvoiceEntity.
 *
 * Notice, this object is used to represent the state of an 
 * InvoiceEntity object. This value object
 * Is not connected to the database in any way, it is just a normal object used 
 * as a container for data from an EJB. 
 *
 */
public class InvoiceDTO
   extends com.csr.common.dto.BaseDTO
   implements java.io.Serializable, java.lang.Cloneable 
{

   private java.lang.String invoiceNumber;
   private boolean invoiceNumberHasBeenSet = false;

   private java.lang.String invoiceDate;
   private boolean invoiceDateHasBeenSet = false;

   private java.lang.String terms;
   private boolean termsHasBeenSet = false;

   private java.lang.String purpose;
   private boolean purposeHasBeenSet = false;

   private java.lang.String purchaseOrderNum;
   private boolean purchaseOrderNumHasBeenSet = false;

   private java.lang.Boolean exempt;
   private boolean exemptHasBeenSet = false;

   private java.lang.String datePrinted;
   private boolean datePrintedHasBeenSet = false;

   private java.lang.String primaryKey;

   public InvoiceDTO()
   {
   }

   public InvoiceDTO( java.lang.String invoiceNumber,java.lang.String invoiceDate,java.lang.String terms,java.lang.String purpose,java.lang.String purchaseOrderNum,java.lang.Boolean exempt,java.lang.String datePrinted )
   {
       setInvoiceNumber(invoiceNumber);
       setInvoiceDate(invoiceDate);
       setTerms(terms);
       setPurpose(purpose);
       setPurchaseOrderNum(purchaseOrderNum);
       setExempt(exempt);
       setDatePrinted(datePrinted);
	   primaryKey = this.getInvoiceNumber();
   }

   /**
    * @deprecated use {@link #clone}
    */
   public InvoiceDTO( InvoiceDTO otherValue )
   {
	  this.invoiceNumber = otherValue.invoiceNumber;
	  invoiceNumberHasBeenSet = true;
	  this.invoiceDate = otherValue.invoiceDate;
	  invoiceDateHasBeenSet = true;
	  this.terms = otherValue.terms;
	  termsHasBeenSet = true;
	  this.purpose = otherValue.purpose;
	  purposeHasBeenSet = true;
	  this.purchaseOrderNum = otherValue.purchaseOrderNum;
	  purchaseOrderNumHasBeenSet = true;
	  this.exempt = otherValue.exempt;
	  exemptHasBeenSet = true;
	  this.datePrinted = otherValue.datePrinted;
	  datePrintedHasBeenSet = true;

	  primaryKey = this.getInvoiceNumber();
   }

   public java.lang.String getPrimaryKey()
   {
	  return primaryKey;
   }

   public void setPrimaryKey( java.lang.String primaryKey)
   {
      // it's also nice to update PK object - just in case
      // somebody would ask for it later...
      this.primaryKey = primaryKey;
	  setInvoiceNumber( primaryKey );
   }

   public java.lang.String getInvoiceNumber()
   {
	  return this.invoiceNumber;
   }

   public void setInvoiceNumber( java.lang.String invoiceNumber )
   {
	  this.invoiceNumber = invoiceNumber;
	  invoiceNumberHasBeenSet = true;

      primaryKey = invoiceNumber;
   }

   public boolean invoiceNumberHasBeenSet(){
	  return invoiceNumberHasBeenSet;
   }
   public java.lang.String getInvoiceDate()
   {
	  return this.invoiceDate;
   }

   public void setInvoiceDate( java.lang.String invoiceDate )
   {
	  this.invoiceDate = invoiceDate;
	  invoiceDateHasBeenSet = true;

   }

   public boolean invoiceDateHasBeenSet(){
	  return invoiceDateHasBeenSet;
   }
   public java.lang.String getTerms()
   {
	  return this.terms;
   }

   public void setTerms( java.lang.String terms )
   {
	  this.terms = terms;
	  termsHasBeenSet = true;

   }

   public boolean termsHasBeenSet(){
	  return termsHasBeenSet;
   }
   public java.lang.String getPurpose()
   {
	  return this.purpose;
   }

   public void setPurpose( java.lang.String purpose )
   {
	  this.purpose = purpose;
	  purposeHasBeenSet = true;

   }

   public boolean purposeHasBeenSet(){
	  return purposeHasBeenSet;
   }
   public java.lang.String getPurchaseOrderNum()
   {
	  return this.purchaseOrderNum;
   }

   public void setPurchaseOrderNum( java.lang.String purchaseOrderNum )
   {
	  this.purchaseOrderNum = purchaseOrderNum;
	  purchaseOrderNumHasBeenSet = true;

   }

   public boolean purchaseOrderNumHasBeenSet(){
	  return purchaseOrderNumHasBeenSet;
   }
   public java.lang.Boolean getExempt()
   {
	  return this.exempt;
   }

   public void setExempt( java.lang.Boolean exempt )
   {
	  this.exempt = exempt;
	  exemptHasBeenSet = true;

   }

   public boolean exemptHasBeenSet(){
	  return exemptHasBeenSet;
   }
   public java.lang.String getDatePrinted()
   {
	  return this.datePrinted;
   }

   public void setDatePrinted( java.lang.String datePrinted )
   {
	  this.datePrinted = datePrinted;
	  datePrintedHasBeenSet = true;

   }

   public boolean datePrintedHasBeenSet(){
	  return datePrintedHasBeenSet;
   }

   public String toString()
   {
	  StringBuffer str = new StringBuffer("{");

	  str.append("invoiceNumber=" + getInvoiceNumber() + " " + "invoiceDate=" + getInvoiceDate() + " " + "terms=" + getTerms() + " " + "purpose=" + getPurpose() + " " + "purchaseOrderNum=" + getPurchaseOrderNum() + " " + "exempt=" + getExempt() + " " + "datePrinted=" + getDatePrinted());
	  str.append('}');

	  return(str.toString());
   }

   /**
    * A Value Object has an identity if the attributes making its Primary Key have all been set. An object without identity is never equal to any other object.
    *
    * @return true if this instance has an identity.
    */
   protected boolean hasIdentity()
   {
	  return invoiceNumberHasBeenSet;
   }

   /**
    *
    * @deprecated use {@link #equals}
    */
   public boolean isIdentical(Object other)
   {
          if (other instanceof InvoiceDTO)
          {
                 InvoiceDTO that = (InvoiceDTO) other;
                 boolean lEquals = true;
                 if( this.invoiceDate == null )
                 {
                        lEquals = lEquals && ( that.invoiceDate == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.invoiceDate.equals( that.invoiceDate );
                 }
                 if( this.terms == null )
                 {
                        lEquals = lEquals && ( that.terms == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.terms.equals( that.terms );
                 }
                 if( this.purpose == null )
                 {
                        lEquals = lEquals && ( that.purpose == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.purpose.equals( that.purpose );
                 }
                 if( this.purchaseOrderNum == null )
                 {
                        lEquals = lEquals && ( that.purchaseOrderNum == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.purchaseOrderNum.equals( that.purchaseOrderNum );
                 }
                 if( this.exempt == null )
                 {
                        lEquals = lEquals && ( that.exempt == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.exempt.equals( that.exempt );
                 }
                 if( this.datePrinted == null )
                 {
                        lEquals = lEquals && ( that.datePrinted == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.datePrinted.equals( that.datePrinted );
                 }

                 return lEquals;
          }
          else
          {
                 return false;
          }
   }

    public boolean equals(Object other) {

        //If it's not the correct type, clearly it isn't equal to this.
        if (!(other instanceof InvoiceDTO)) { 
            return false;
        }

        return equals((InvoiceDTO) other);
    }

    /**
     * This class is not using strict ordering. This means that the object is not Comparable, and
     * each check for equality will test all members for equality. We do not check collections for
     * equality however, so you would be wise to not use this if you have collection typed EJB References.
     */
    public boolean equals(InvoiceDTO that) {

        //try to get lucky.
        if (this == that) {
            return true;
        }
        //this clearly isn't null.
        if(null == that) {
            return false;
        }

        if(this.invoiceNumber != that.invoiceNumber) {

            if( this.invoiceNumber == null || that.invoiceNumber == null ) {
                return false;
            }

            if(!this.invoiceNumber.equals(that.invoiceNumber)) {
                return false;
            }

        }

        if(this.invoiceDate != that.invoiceDate) {

            if( this.invoiceDate == null || that.invoiceDate == null ) {
                return false;
            }

            if(!this.invoiceDate.equals(that.invoiceDate)) {
                return false;
            }

        }

        if(this.terms != that.terms) {

            if( this.terms == null || that.terms == null ) {
                return false;
            }

            if(!this.terms.equals(that.terms)) {
                return false;
            }

        }

        if(this.purpose != that.purpose) {

            if( this.purpose == null || that.purpose == null ) {
                return false;
            }

            if(!this.purpose.equals(that.purpose)) {
                return false;
            }

        }

        if(this.purchaseOrderNum != that.purchaseOrderNum) {

            if( this.purchaseOrderNum == null || that.purchaseOrderNum == null ) {
                return false;
            }

            if(!this.purchaseOrderNum.equals(that.purchaseOrderNum)) {
                return false;
            }

        }

        if(this.exempt != that.exempt) {

            if( this.exempt == null || that.exempt == null ) {
                return false;
            }

            if(!this.exempt.equals(that.exempt)) {
                return false;
            }

        }

        if(this.datePrinted != that.datePrinted) {

            if( this.datePrinted == null || that.datePrinted == null ) {
                return false;
            }

            if(!this.datePrinted.equals(that.datePrinted)) {
                return false;
            }

        }

        return true;

    }

    public Object clone() throws java.lang.CloneNotSupportedException {
        InvoiceDTO other = (InvoiceDTO) super.clone();

        return other;
    }

    public ReadOnlyInvoiceDTO getReadOnlyInvoiceDTO() {
        return new ReadOnlyInvoiceDTO();
    }

    public int hashCode(){
	  int result = 17;
      result = 37*result + ((this.invoiceNumber != null) ? this.invoiceNumber.hashCode() : 0);

      result = 37*result + ((this.invoiceDate != null) ? this.invoiceDate.hashCode() : 0);

      result = 37*result + ((this.terms != null) ? this.terms.hashCode() : 0);

      result = 37*result + ((this.purpose != null) ? this.purpose.hashCode() : 0);

      result = 37*result + ((this.purchaseOrderNum != null) ? this.purchaseOrderNum.hashCode() : 0);

      result = 37*result + ((this.exempt != null) ? this.exempt.hashCode() : 0);

      result = 37*result + ((this.datePrinted != null) ? this.datePrinted.hashCode() : 0);

	  return result;
    }

    /**
     * Covariant function so the compiler can choose the proper one at compile time,
     * eliminates the need for XDoclet to really understand compiletime typing.
     *
     * Read only collections need to be synchronized. Once we start giving out handles
     * to these collections, they'll be used in other threads sooner or later. 
     */
    private static java.util.Collection wrapCollection(java.util.Collection input) {
        return java.util.Collections.synchronizedCollection(input);
    }
    /**
     * Covariant function so the compiler can choose the proper one at compile time,
     * eliminates the need for XDoclet to really understand compiletime typing.
     *
     * Read only collections need to be synchronized. Once we start giving out handles
     * to these collections, they'll be used in other threads sooner or later. 
     */
    private static java.util.Set wrapCollection(java.util.Set input) {
        return java.util.Collections.synchronizedSet(input);
    }
    /**
     * Covariant function. This is used in covariant form so that the compiler
     * can do some of our conditional branches for us. If I made these functions
     * have different names, then XDoclet would have to choose between them based on 
     * compiletime types, that wouldn't be easy. 
     */
    private static java.util.Collection wrapReadOnly(java.util.Collection input) {
        return java.util.Collections.unmodifiableCollection(input);
    }
    /**
     * Covariant function. This is used in covariant form so that the compiler
     * can do some of our conditional branches for us. If I made these functions
     * have different names, then XDoclet would have to choose between them based on 
     * compiletime types, that wouldn't be easy. 
     */
    private static java.util.Set wrapReadOnly(java.util.Set input) {
        return java.util.Collections.unmodifiableSet(input);
    }

    private final class ReadOnlyInvoiceDTO 
    implements java.lang.Cloneable, java.io.Serializable 
    {
        private InvoiceDTO underlying() {
            return InvoiceDTO.this;
        }

       public java.lang.String getInvoiceNumber() {
              return underlying().invoiceNumber;
       }

       public java.lang.String getInvoiceDate() {
              return underlying().invoiceDate;
       }

       public java.lang.String getTerms() {
              return underlying().terms;
       }

       public java.lang.String getPurpose() {
              return underlying().purpose;
       }

       public java.lang.String getPurchaseOrderNum() {
              return underlying().purchaseOrderNum;
       }

       public java.lang.Boolean getExempt() {
              return underlying().exempt;
       }

       public java.lang.String getDatePrinted() {
              return underlying().datePrinted;
       }

        public int hashCode() {
            return 101 * underlying().hashCode();
        }

        public boolean equals(Object o) {
            if(o instanceof ReadOnlyInvoiceDTO) {
                return this.equals((ReadOnlyInvoiceDTO) o);
            }
            return false;
        }

        public boolean equals(ReadOnlyInvoiceDTO that) {
            if(null == that) {
                return false;
            }

            return this.underlying().equals(that.underlying());
        }

    }

}
